{"version":3,"sources":["../src/utils.js"],"names":[],"mappings":";;;;;AAAe,MAAM,KAAK,CAAC;AACzB,SAAO,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE;AAC7C,WAAO,KAAK,CAAC,aAAa,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,IAAI,EAAE,CAAA,GAAI,KAAK,EAAE,KAAK,CAAC,CAAC;GACzF;;AAED,SAAO,aAAa,CAAC,MAAM,EAAE,KAAK,EAAE;AAClC,QAAI,MAAM,IAAI,IAAI,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACzC,aAAO,EAAE,CAAC;KACX;;AAED,WAAO,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,GAAG,CAAC;GAC1C;;AAED,SAAO,MAAM,CAAC,UAAU,EAAE,KAAK,EAAE;AAC/B,QAAI,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;AACjD,aAAO,EAAE,CAAC;KACX;;AAED,SAAK,GAAG,KAAK,IAAI,GAAG,CAAC;;AAErB,UAAM,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,CAAC,CAAC;;AAE1E,WAAO,KAAK,GAAG,OAAO,GAAG,KAAK,CAAC;GAChC;;AAED,SAAO,eAAe,CAAC,QAAQ,EAAE,kBAAkB,EAAE,YAAY,EAAE,MAAM,EAAE;AACzE,QAAI,kBAAkB,IAAI,IAAI,EAAE;AAC9B,wBAAkB,GAAG,IAAI,CAAC;KAC3B;;AAED,QAAI,YAAY,IAAI,IAAI,EAAE;AACxB,kBAAY,GAAG,KAAK,CAAC;KACtB;;AAED,UAAM,IAAI,GAAG,EAAE,CAAC;;AAEhB,SAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;AAC9B,UAAI,YAAY,EAAE;AAChB,eAAO,CAAC,MAAM,GAAG,MAAM,CAAC;OACzB;;AAED,UAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;AAEnB,UAAI,OAAO,GAAG,IAAI,CAAC;;AAEnB,UAAI,CAAC,kBAAkB,IAAI,OAAO,CAAC,IAAI,KAAK,YAAY,EAAE;AACxD,eAAO,GAAG,KAAK,CAAC;OACjB;;AAED,UAAI,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE;AAC/B,cAAM,QAAQ,GAAG,KAAK,CAAC,eAAe,CAAC,OAAO,CAAC,QAAQ,EAAE,kBAAkB,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;AACpG,aAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;OAC5C;KACF;;AAED,WAAO,IAAI,CAAC;GACb;CACF;kBAzDoB,KAAK","file":"utils.js","sourcesContent":["export default class Utils {\n  static tableName(schema, prefix, quote, table) {\n    return Utils.escapedSchema(schema, quote) + Utils.escape((prefix || '') + table, quote);\n  }\n\n  static escapedSchema(schema, quote) {\n    if (schema == null || schema.length === 0) {\n      return '';\n    }\n\n    return Utils.escape(schema, quote) + '.';\n  }\n\n  static escape(identifier, quote) {\n    if (identifier == null || identifier.length === 0) {\n      return '';\n    }\n\n    quote = quote || '\"';\n\n    const escaped = identifier.replace(new RegExp(quote, 'g'), quote + quote);\n\n    return quote + escaped + quote;\n  }\n\n  static flattenElements(elements, recurseRepeatables, assignParent, parent) {\n    if (recurseRepeatables == null) {\n      recurseRepeatables = true;\n    }\n\n    if (assignParent == null) {\n      assignParent = false;\n    }\n\n    const flat = [];\n\n    for (const element of elements) {\n      if (assignParent) {\n        element.parent = parent;\n      }\n\n      flat.push(element);\n\n      let recurse = true;\n\n      if (!recurseRepeatables && element.type === 'Repeatable') {\n        recurse = false;\n      }\n\n      if (recurse && element.elements) {\n        const children = Utils.flattenElements(element.elements, recurseRepeatables, assignParent, element);\n        Array.prototype.push.apply(flat, children);\n      }\n    }\n\n    return flat;\n  }\n}\n"]}