{"version":3,"sources":["../src/utils.js"],"names":[],"mappings":";;;;;;;;;;IAAqB,K;;;;;;;8BACF,M,EAAQ,M,EAAQ,K,EAAO,K,EAAO;AAC7C,aAAO,MAAM,aAAN,CAAoB,MAApB,EAA4B,KAA5B,IAAqC,MAAM,MAAN,CAAa,CAAC,UAAU,EAAX,IAAiB,KAA9B,EAAqC,KAArC,CAA5C;AACD;;;kCAEoB,M,EAAQ,K,EAAO;AAClC,UAAI,UAAU,IAAV,IAAkB,OAAO,MAAP,KAAkB,CAAxC,EAA2C;AACzC,eAAO,EAAP;AACD;;AAED,aAAO,MAAM,MAAN,CAAa,MAAb,EAAqB,KAArB,IAA8B,GAArC;AACD;;;2BAEa,U,EAAY,K,EAAO;AAC/B,UAAI,cAAc,IAAd,IAAsB,WAAW,MAAX,KAAsB,CAAhD,EAAmD;AACjD,eAAO,EAAP;AACD;;AAED,cAAQ,SAAS,GAAjB;;AAEA,UAAM,UAAU,WAAW,OAAX,CAAmB,IAAI,MAAJ,CAAW,KAAX,EAAkB,GAAlB,CAAnB,EAA2C,QAAQ,KAAnD,CAAhB;;AAEA,aAAO,QAAQ,OAAR,GAAkB,KAAzB;AACD;;;oCAEsB,Q,EAAU,kB,EAAoB,Y,EAAc,M,EAAQ;AACzE,UAAI,sBAAsB,IAA1B,EAAgC;AAC9B,6BAAqB,IAArB;AACD;;AAED,UAAI,gBAAgB,IAApB,EAA0B;AACxB,uBAAe,KAAf;AACD;;AAED,UAAM,OAAO,EAAb;;AATyE;AAAA;AAAA;;AAAA;AAWzE,6BAAsB,QAAtB,8HAAgC;AAAA,cAArB,OAAqB;;AAC9B,cAAI,YAAJ,EAAkB;AAChB,oBAAQ,MAAR,GAAiB,MAAjB;AACD;;AAED,eAAK,IAAL,CAAU,OAAV;;AAEA,cAAI,UAAU,IAAd;;AAEA,cAAI,CAAC,kBAAD,IAAuB,QAAQ,IAAR,KAAiB,YAA5C,EAA0D;AACxD,sBAAU,KAAV;AACD;;AAED,cAAI,WAAW,QAAQ,QAAvB,EAAiC;AAC/B,gBAAM,WAAW,MAAM,eAAN,CAAsB,QAAQ,QAA9B,EAAwC,kBAAxC,EAA4D,YAA5D,EAA0E,OAA1E,CAAjB;AACA,kBAAM,SAAN,CAAgB,IAAhB,CAAqB,KAArB,CAA2B,IAA3B,EAAiC,QAAjC;AACD;AACF;AA5BwE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA8BzE,aAAO,IAAP;AACD;;;;;;kBAxDkB,K","file":"utils.js","sourcesContent":["export default class Utils {\n  static tableName(schema, prefix, quote, table) {\n    return Utils.escapedSchema(schema, quote) + Utils.escape((prefix || '') + table, quote);\n  }\n\n  static escapedSchema(schema, quote) {\n    if (schema == null || schema.length === 0) {\n      return '';\n    }\n\n    return Utils.escape(schema, quote) + '.';\n  }\n\n  static escape(identifier, quote) {\n    if (identifier == null || identifier.length === 0) {\n      return '';\n    }\n\n    quote = quote || '\"';\n\n    const escaped = identifier.replace(new RegExp(quote, 'g'), quote + quote);\n\n    return quote + escaped + quote;\n  }\n\n  static flattenElements(elements, recurseRepeatables, assignParent, parent) {\n    if (recurseRepeatables == null) {\n      recurseRepeatables = true;\n    }\n\n    if (assignParent == null) {\n      assignParent = false;\n    }\n\n    const flat = [];\n\n    for (const element of elements) {\n      if (assignParent) {\n        element.parent = parent;\n      }\n\n      flat.push(element);\n\n      let recurse = true;\n\n      if (!recurseRepeatables && element.type === 'Repeatable') {\n        recurse = false;\n      }\n\n      if (recurse && element.elements) {\n        const children = Utils.flattenElements(element.elements, recurseRepeatables, assignParent, element);\n        Array.prototype.push.apply(flat, children);\n      }\n    }\n\n    return flat;\n  }\n}\n"]}